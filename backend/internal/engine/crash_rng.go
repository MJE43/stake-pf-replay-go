package engine

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"math"
	"strconv"
)

// CrashRNG implements the salt-chain RNG used by Crash and Slide games.
//
// Unlike the standard HMAC-SHA256 byte generator, Crash/Slide uses a
// hash chain: each game hash is derived from the *previous* game hash
// by SHA-256 hashing it. The game result (crash point) is then computed
// by HMAC-SHA256(gameHash, salt).
//
// The chain runs backwards: the first game uses the Nth hash, and each
// subsequent game uses the (N-1)th hash, etc. To verify, you start from
// the terminating hash and hash forward.
//
// Reference:
//   crashPoint = f(HMAC_SHA256(gameHash, salt))
//   where f converts the first 8 hex chars to a multiplier using the
//   Stake-specific formula with a 3% house edge.

const (
	// CrashHouseEdge is the house edge percentage for Crash/Slide.
	CrashHouseEdge = 0.03

	// CrashMaxMultiplier caps the crash point to prevent overflow.
	CrashMaxMultiplier = 1000000.0
)

// CrashResult computes the crash point for a single game given
// the game hash and the salt (public seed).
//
// Algorithm:
// 1. HMAC-SHA256(gameHash, salt) -> hex string
// 2. Take first 8 hex characters -> int value
// 3. If int value % 33 == 0, crash at 1.00x (instant crash)
// 4. Otherwise: result = (2^32 / (int + 1)) * (1 - houseEdge)
func CrashResult(gameHash, salt string) float64 {
	// HMAC-SHA256 with game hash as message and salt as key
	h := hmac.New(sha256.New, []byte(salt))
	h.Write([]byte(gameHash))
	result := hex.EncodeToString(h.Sum(nil))

	// Take first 8 hex chars (52 bits of entropy via 4 bytes)
	if len(result) < 8 {
		return 1.0
	}
	hexPart := result[:8]

	// Parse as unsigned 32-bit integer
	val, err := strconv.ParseUint(hexPart, 16, 64)
	if err != nil {
		return 1.0
	}

	// Instant crash check: ~3% of the time
	if val%33 == 0 {
		return 1.0
	}

	// Calculate multiplier with house edge
	e := math.Pow(2, 32)
	multiplier := (e / (float64(val) + 1)) * (1 - CrashHouseEdge)

	// Floor to 2 decimal places (Stake convention)
	multiplier = math.Floor(multiplier*100) / 100

	if multiplier < 1.0 {
		return 1.0
	}
	if multiplier > CrashMaxMultiplier {
		return CrashMaxMultiplier
	}

	return multiplier
}

// GenerateHashChain generates a hash chain of the given length starting
// from the terminating hash. Returns the hashes in play order (first game first).
//
// The chain is generated by repeatedly SHA-256 hashing:
//   hash[n] = SHA256(hash[n-1])
//
// The terminating hash is public and can be used to verify the entire chain.
func GenerateHashChain(terminatingHash string, count int) []string {
	chain := make([]string, count)

	currentHash := terminatingHash
	// Generate chain backwards
	for i := count - 1; i >= 0; i-- {
		chain[i] = currentHash
		h := sha256.Sum256([]byte(currentHash))
		currentHash = hex.EncodeToString(h[:])
	}

	return chain
}

// VerifyHashChain verifies that a hash chain is valid by checking that
// each hash is the SHA-256 of the next hash in the chain.
// Returns true if the chain is valid.
func VerifyHashChain(chain []string) bool {
	for i := 0; i < len(chain)-1; i++ {
		h := sha256.Sum256([]byte(chain[i+1]))
		expected := hex.EncodeToString(h[:])
		if chain[i] != expected {
			return false
		}
	}
	return true
}

// CrashResultsFromChain computes crash points for an entire hash chain
// with the given salt. Returns results in the same order as the chain.
func CrashResultsFromChain(chain []string, salt string) []float64 {
	results := make([]float64, len(chain))
	for i, hash := range chain {
		results[i] = CrashResult(hash, salt)
	}
	return results
}
