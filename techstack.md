# Tech Stack — Stake PF Replay

## Architecture (2-tier)

* **Web App + BFF (TypeScript/React):** **Next.js 14** (App Router) runs the UI *and* lightweight backend routes (backend-for-frontend). It handles auth, input validation, and orchestration.
* **Compute Engine (High-perf):** **Go service** exposes a small HTTP API for scans/verify. It does the HMAC → floats → game mapping at multi-core speed and writes results.

This gives you a TypeScript backend surface for DX, and Go where raw throughput actually matters.

---

## Frontend + BFF (Next.js)

* **Framework:** Next.js 14 (TypeScript, App Router, Server Actions where useful)
* **UI:** React 18, Tailwind, shadcn/ui
* **Data fetching:** TanStack Query on the client; direct `fetch()` from Server Actions for trusted calls
* **Validation:** Zod (shared schema between client and API routes)
* **State:** Local: React state; cross-page: Zustand (lightweight) or just Query cache
* **Charts:** Recharts (or Visx) for histograms/distributions
* **Realtime (optional):** SSE (preferred) or WebSockets via `nextjs-websocket`/`socket.io` for progressive scan updates
* **Auth (if needed):** NextAuth.js (Email/OAuth)

**Role:** The BFF receives requests from the UI, validates them, then calls the Go service. It never does CPU-heavy loops.

---

## Compute Engine (Go)

* **Language:** Go 1.22+
* **HTTP:** chi / net/http
* **Parallelism:** goroutines + worker pool (bounded); `GOMAXPROCS` tuned
* **DB access:** pgx (Postgres) or modernc.org/sqlite (dev)
* **Migrations:** goose
* **Why Go:** predictable, fast, single binary, AI-friendly to maintain

**Role:** Deterministic evaluation and range scanning. Optional persistence of runs + hits.

---

## Database & Storage

* **Primary DB:** Postgres in prod; SQLite for local/dev
* **Access pattern:**

  * **Option A (simplest):** Go service owns DB reads/writes; Next.js only calls Go.
  * **Option B (shared DB):** Go writes results; Next.js reads via **Prisma**. (Use only if you need complex UI filters directly from DB.)
* **Cache/Queue (optional):** Redis (BullMQ from Next.js if you want async orchestration/UI progress bars)
* **Exports:** CSV generated by Go; stored in S3 (or streamed direct)

---

## APIs & Contracts

* **Between Next.js and Go:** JSON over HTTP (REST).

  * `POST /scan` — large range, returns summary and (optionally paginated/streamed) hits
  * `POST /verify` — single nonce with full details
  * `GET /games` — metadata and params schema
  * `POST /seed/hash` — sha256 of server seed
* **Schemas:** Zod in Next.js ↔ Go structs with OpenAPI (oapi-codegen optional). Keep enums/IDs identical.
* **Streaming:** Prefer **SSE** for incremental summaries/hits; it’s simpler than websockets and perfect for append-only streams.

---

## DevX & Ops

* **Monorepo:** pnpm workspace (web) + Go module(s)
* **Tooling:**

  * Next.js: ESLint, Prettier, TypeScript strict
  * Go: `golangci-lint`, `-race` in CI, unit tests with golden vectors
* **CI/CD:** GitHub Actions

  * Build & test Next.js
  * Build Go binaries; run unit tests; publish Docker images
* **Containers:**

  * `web` (Next.js), `engine` (Go), `db` (Postgres), `redis` (optional) via docker-compose
* **Observability:**

  * Go: `pprof`, structured logs (zerolog), Prometheus metrics (optional)
  * Next.js: request logs + edge timings

---

## Why not a pure TypeScript backend?

* Node Worker Threads + pure TS can work, but you’ll fight GC churn and slower tight loops at the million-nonce scale.
* Keeping compute in Go lets your TS/React team stay productive while scans stay brutally fast. If you ever *must* keep everything Node, you can shell out to the Go binary or call it over localhost HTTP with zero drama.

---

## Growth path

* Start: Next.js (BFF) + Go (compute) + SQLite
* Scale: switch to Postgres, add SSE for live updates
* Later: add Redis/BullMQ if you want queued “long scans” and resumable jobs
* Much later: consider gRPC between BFF and Go if the API surface grows

---

## Quick module map

```
/web            # Next.js (TypeScript, App Router)
  app/          # pages & server actions
  lib/          # zod schemas, API client
  components/   # UI
  api/          # (optional) BFF routes -> call Go service

/engine         # Go service
  internal/engine/   # RNG, selection, core
  internal/games/    # pump, limbo, dice, ...
  internal/scan/     # worker pool
  internal/api/      # REST handlers
  internal/store/    # DB
  cmd/pf-service/    # main
```

Short version: **Next.js (TS/React) runs the “backend” users interact with; Go does the math.** It’s clean, fast, and easy to evolve.
